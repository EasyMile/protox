TODO.
- Use the tuple {tag , name, kind, type} in Decode (thus remove %Field, %Message, %Enumeration)
- Cleanup BuildMessage (the generation of encoding logic should be in Encode)
- configurable default values (for protobuf 2)
- Should decode returns {:ok, msg}|{:error, reason}? (and a function decode!())
- .proto (v3 only) parser
- https://ebertapp.io
- travis-ci
- https://github.com/google/protobuf/tree/master/conformance


Optimize
- metaprog decoder for each message?
- choose a data structure to store key/values pairs, where the key is the field tag in a message.
  however, tags may not be continuous (e.g. 1,2,3, 100, 1001). thus a sparse data structure is needed.
  * Tuple?
  * erlang's array?
  * Map?
  * still needed with metaprog?

Conformance
- Parsing unknown values
  On the wire, a .proto map is equivalent to a map entry message for each key/value pair, while the map itself is a repeated field of map entries. Like ordinary message types, it's possible for a parsed map entry message to have unknown fields: for example a field of type int64 in a map defined as map<int32, string>.
  -If there are unknown fields in the wire format of a map entry message, they will be discarded.- Done
  If there is an unknown enum value in the wire format of a map entry message, it's handled differently in proto2 and proto3. In proto2, the whole map entry message is put into the unknown field set of the containing message. In proto3, it is put into a map field as if it is a known enum value.
- https://github.com/google/protobuf/tree/master/conformance
